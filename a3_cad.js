"use strict";

var canvas ;
var gl ;

var maxNumVertices = 20000;

var radius_default      = 0.4;
var height_default      = 0.8;
var rotAngleDeg_default =  0;

var scaleVec_default    = [1., 1., 1.];
var rotAxis_default     = [0., 1., 0.];
var transVec_default    = [0., 0., 0.];

var scale_sliderFac = 50.;
var shapeCounter    =  0;


var vertices     = [];
var vertexColors = [];

// Edges generated by gl.LINE_LOOP
var nEdgeVerts   = [];

var edgeColor;

// Faces generated by gl.TRIANGLE_FAN
var nFaces       =  0;
var nFaceVerts   = [];

var faceColor;

var totalPoints  =  0 ;

var faceColorI = 3;
var edgeColorI = 0;

var shapeType = 0;
var baseShape = 0;

var curvedEdges = [];

var radius      = radius_default;
var height      = height_default;
var rotAngleDeg = rotAngleDeg_default;

var scaleVec    = vec3(scaleVec_default);
var rotAxis     = vec3(rotAxis_default);
var transVec    = vec3(transVec_default);

var nCircVerts  = 20; // needs to be a multiple of 4
                      // for present method of sphere construction

var bDraw            = false;
var bTransform       = false;
var bTransform_fromOrig = true;
// setting this to false not working, and would require significant mods
var bInitDraw        = false;
var bShowCurvedEdges = true;
var bWireframe       = false;
var CIRC_BASE_IND    = 0;

var rotAxisN;
var shape_archetype;
var scaleMat;
var rotationMat;
var translationMat;

var vBuffer;
var cBuffer;


var shapeVerts_start = [];
var shapeVerts_end   = [];
var shapeInd         = -1;

var colors = [
    vec4( 0.0, 0.0, 0.0, 1.0 ),  // black
    vec4( 1.0, 1.0, 1.0, 1.0 ),  // white
    vec4( 1.0, 0.0, 0.0, 1.0 ),  // red
    vec4( 0.0, 1.0, 0.0, 1.0 ),  // green
    vec4( 0.0, 0.0, 1.0, 1.0 )   // blue
  ];

// Define outside of onload() so we can set these elsewhere.
var sliderRot;

var sliderScaleX;
var sliderScaleY;
var sliderScaleZ;

var sliderTransX;
var sliderTransY;
var sliderTransZ;

var sliderAxisX;
var sliderAxisY;
var sliderAxisZ;

var check_showCurvedEdges;
var check_wireframe;

var fileSummaryStr = '';
  
  
function bDraw_check()
{
  bDraw = true;
  if (parseInt(faceColorI) === -1)
    bDraw = false;
  if (parseInt(edgeColorI) === -1)
    bDraw = false;
  if (parseInt(shapeType)  === -1)
    bDraw = false;
  if (parseInt(baseShape)  === -1)
    bDraw = false;
}



window.onload = function init()
{
  canvas = document.getElementById( "gl-canvas" );

  gl = WebGLUtils.setupWebGL( canvas );
  if ( !gl ) { alert( "WebGL isn't available" ); }

  //  Configure WebGL
  gl.viewport( 0, 0, canvas.width, canvas.height );
  gl.clearColor( 1.0, 1.0, 1.0, 1.0 );
  gl.enable(gl.DEPTH_TEST);;


  //  Load shaders and initialize attribute buffers
  var program = initShaders( gl, "vertex-shader", "fragment-shader" );
  gl.useProgram( program );
  
  

  // color array atrribute buffer

  vBuffer = gl.createBuffer();
  gl.bindBuffer( gl.ARRAY_BUFFER, vBuffer );
  gl.bufferData( gl.ARRAY_BUFFER, 8*maxNumVertices, gl.STATIC_DRAW );

  var vPosition = gl.getAttribLocation(program, "vPosition");
  gl.vertexAttribPointer(vPosition, 4, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(vPosition);

  cBuffer = gl.createBuffer();
  gl.bindBuffer( gl.ARRAY_BUFFER, cBuffer );
  gl.bufferData( gl.ARRAY_BUFFER, 16*maxNumVertices, gl.STATIC_DRAW );

  var vColor = gl.getAttribLocation( program, "vColor" );
  gl.vertexAttribPointer( vColor, 4, gl.FLOAT, false, 0, 0 );
  gl.enableVertexAttribArray( vColor );

  // Event listeners
  

  faceColor  = colors[faceColorI];
  var faceColorIPicker = document.getElementById("faceColorI");
  faceColorIPicker.selectedIndex = faceColorI;
  faceColorIPicker.addEventListener("click",
    function()
    {
      faceColorI = faceColorIPicker.selectedIndex;
      faceColor  = colors[faceColorI];
    }
  )  

  edgeColor  = colors[edgeColorI];
  var edgeColorIPicker = document.getElementById("edgeColorI");
  edgeColorIPicker.selectedIndex = edgeColorI;
  edgeColorIPicker.addEventListener("click",
    function()
    {
      edgeColorI = edgeColorIPicker.selectedIndex;
      edgeColor  = colors[edgeColorI];
    }
  )  

  var shapeTypePicker = document.getElementById("shapeType");
  shapeTypePicker.value = shapeType; 
  shapeTypePicker.addEventListener("click",
    function()
    {
      shapeType = parseInt(shapeTypePicker.value);
    }
  )  

  var baseShapePicker = document.getElementById("baseShape");
  baseShapePicker.value = baseShape;
  baseShapePicker.addEventListener("click",
    function()
    {
      baseShape = parseInt(baseShapePicker.value);
    }
  )  

  sliderRot = document.getElementById("sliderRot");
  sliderRot.value = rotAngleDeg;
  sliderRot.addEventListener("mouseup",
    function()
    {
      rotAngleDeg = parseInt(sliderRot.value);
      set_textBoxes();
      draw_shape();
      set_rotationMat();
      render();
    }
  )

 
  sliderScaleX = document.getElementById("sliderScaleX");
  sliderScaleY = document.getElementById("sliderScaleY");
  sliderScaleZ = document.getElementById("sliderScaleZ");

  sliderScaleX.value = scaleVec[0] * scale_sliderFac ;
  sliderScaleX.addEventListener("mouseup",
    function()
    {
      scaleVec[0] = sliderScaleX.value / scale_sliderFac ;
      set_textBoxes();
      set_scaleMat();
      render();
    }
  )

  sliderScaleY.value = scaleVec[1] * scale_sliderFac ;
  sliderScaleY.addEventListener("mouseup",
    function()
    {
      scaleVec[1] = sliderScaleY.value / scale_sliderFac ;
      set_textBoxes();
      set_scaleMat();
      render();
    }
  )

  sliderScaleZ.value = scaleVec[2] * scale_sliderFac ;
  sliderScaleZ.addEventListener("mouseup",
    function()
    {
      scaleVec[2] = sliderScaleZ.value / scale_sliderFac ;
      set_textBoxes();
      set_scaleMat();
      render();
    }
  )

 
  sliderAxisX = document.getElementById("sliderAxisX");
  sliderAxisY = document.getElementById("sliderAxisY");
  sliderAxisZ = document.getElementById("sliderAxisZ");

  sliderAxisX.value = rotAxis[0] * 100. ;
  sliderAxisX.addEventListener("mouseup",
    function()
    {
      rotAxis[0] = sliderAxisX.value / 100. ;
      set_textBoxes();
      set_rotationMat();
      render();
    }
  )

  sliderAxisY.value = rotAxis[1] * 100. ;
  sliderAxisY.addEventListener("mouseup",
    function()
    {
      rotAxis[1] = sliderAxisY.value / 100. ;
      set_textBoxes();
      set_rotationMat();
      render();
    }
  )

  sliderAxisZ.value = rotAxis[2] * 100. ;
  sliderAxisZ.addEventListener("mouseup",
    function()
    {
      rotAxis[2] = sliderAxisZ.value / 100. ;
      set_rotationMat();
      set_textBoxes();
      render();
    }
  )

  sliderTransX = document.getElementById("sliderTransX");
  sliderTransY = document.getElementById("sliderTransY");
  sliderTransZ = document.getElementById("sliderTransZ");

  sliderTransX.value = transVec[0] * 100. ;
  sliderTransX.addEventListener("mouseup",
    function()
    {
      transVec[0] = sliderTransX.value / 100. ;
      set_textBoxes();
      set_translationMat();
      render();
    }
  )

  sliderTransY.value = transVec[1] * 100. ;
  sliderTransY.addEventListener("mouseup",
    function()
    {
      transVec[1] = sliderTransY.value / 100. ;
      set_textBoxes();
      set_translationMat();
      render();
    }
  )

  sliderTransZ.value = transVec[2] * 100. ;
  sliderTransZ.addEventListener("mouseup",
    function()
    {
      transVec[2] = sliderTransZ.value / 100. ;
      set_textBoxes();
      set_translationMat();
      render();
    }
  )
  check_showCurvedEdges = document.getElementById("check_showCurvedEdges");
  check_showCurvedEdges.checked = bShowCurvedEdges;
  check_showCurvedEdges.addEventListener("click",
    function()
    {
      transformShape();
      render();
    }
  )
  
  check_wireframe = document.getElementById("check_wireframe");
  check_wireframe.checked = bWireframe;
  check_wireframe.addEventListener("click",
    function()
    {
      transformShape();
      render();
    }
  )
  
  reset_vals();
  
  var writeButton = document.getElementById("writeButton");
  writeButton.addEventListener("click", writeCurrentShapeToConsole);
  
  var writeAllButton = document.getElementById("writeAllButton");
  writeAllButton.addEventListener("click", writeAllShapesToConsole);
  
  var drawButton = document.getElementById("drawButton");
  drawButton.addEventListener("click",
    function()
    {
      bDraw_check();
      if (bDraw)
      {
        if (shapeCounter>0)
          fileSummaryStr += get_currentShapeInfo();
          //get_currentShapeInfo();
        get_currentShapeInfo
        shapeCounter += 1;
        shapeInd += 1;
        bInitDraw = true;
        shapeVerts_start.push(vertices.length);
        reset_vals();
        draw_shape();
        bInitDraw = false;
        shapeVerts_end.push(vertices.length);
        bTransform = true;
        render();
      }
    }
  )

  set_textBoxes();
}


function writeCurrentShapeToConsole()
{
  console.log(get_currentShapeInfo())
}

function get_currentShapeInfo()
{
      var shapeTypeStr, baseShapeStr, faceColorStr, edgeColorStr;

      var strOutCurr = "\n" + "Shape " + shapeCounter + "\n"
      
      // Shape type
      if (shapeType == 0)
        shapeTypeStr = "Sphere";
      else
      if (shapeType == 1)
        shapeTypeStr = "Polygon";
      else
      if (shapeType == 2)
        shapeTypeStr = "Cylinder/Prism";
      else
      if (shapeType == 3)
        shapeTypeStr = "Cone/Pyramid";
      strOutCurr += "Shape type: " + shapeTypeStr + "\n";
      //console.log("Shape type: %s", shapeTypeStr);
      
      // Base shape
      if (shapeType > 0)
      {
        if (baseShape == 0)
          baseShapeStr = "Circle";
        else
        if (baseShape == 3)
          baseShapeStr = "Triangle";
        else
        if (baseShape == 4)
          baseShapeStr = "Square";
        else
        if (baseShape == 5)
          baseShapeStr = "Pentagon";
        else
        if (baseShape == 6)
          baseShapeStr = "Hexagon";
        strOutCurr += "Base shape: " + baseShapeStr + "\n";
        //console.log("Base shape: %s", baseShapeStr);
      }
      
      //Face color
      if (faceColorI==0)
        faceColorStr = "Black";
      else
      if (faceColorI==1)
        faceColorStr = "White";
      else
      if (faceColorI==2)
        faceColorStr = "Red";
      else
      if (faceColorI==3)
        faceColorStr = "Green";
      else
      if (faceColorI==4)
        faceColorStr = "Blue";
      strOutCurr += "Face color:  " + faceColorStr + "\n";
      //console.log("Face color: %s", faceColorStr);
      
      
      //Edge color
      if (edgeColorI==0)
        edgeColorStr = "Black";
      else
      if (edgeColorI==1)
        edgeColorStr = "White";
      else
      if (edgeColorI==2)
        edgeColorStr = "Red";
      else
      if (edgeColorI==3)
        edgeColorStr = "Green";
      else
      if (edgeColorI==4)
        edgeColorStr = "Blue";
      strOutCurr += "Edge color:  " + edgeColorStr + "\n";
      //console.log("Edge color: %s", edgeColorStr);
      
      strOutCurr += "Scale(X,Y,Z) = (" + scaleVec[0] + ", "
          + scaleVec[1] + ", " + scaleVec[2] + ")" + "\n";
      //console.log("Scale(X,Y,Z) = (%f, %f, %f)",
      //            scaleVec[0], scaleVec[1], scaleVec[2]);
      strOutCurr += "Rotation(X,Y,Z; angle) = (" + rotAxis[0] + ", "
                          + ", "+ rotAxis[1] + ", " + rotAxis[2] + ", "
                          + rotAngleDeg + ")" + "\n";
      //console.log("Rotation(X,Y,Z; angle) = (%f, %f, %f; %f)",
      //            rotAxis[0], rotAxis[1], rotAxis[2], rotAngleDeg);
      strOutCurr += "Translation(X,Y,Z) = (" + transVec[0] + ", "
                      + ", " + transVec[1] + ", "
                      + transVec[2] + ")" + "\n";
      //console.log("Translation(X,Y,Z) = (%f, %f, %f)",
      //            transVec[0], transVec[1], transVec[2]);
      
      return strOutCurr;
}

function writeAllShapesToConsole()
{
  console.log(fileSummaryStr);
  writeCurrentShapeToConsole();
}

function reset_vals()
{
  radius = radius_default;
  height = height_default;
  rotAngleDeg = rotAngleDeg_default;
  
  bWireframe = check_wireframe.checked;
  bShowCurvedEdges = check_showCurvedEdges.checked;

  scaleVec = vec3(scaleVec_default);
  rotAxis  = vec3(rotAxis_default);
  transVec = vec3(transVec_default);

  sliderRot.value = rotAngleDeg;
  
  sliderScaleX.value = scaleVec[0] * scale_sliderFac ;
  sliderScaleY.value = scaleVec[1] * scale_sliderFac ;
  sliderScaleZ.value = scaleVec[2] * scale_sliderFac ;
  
  sliderAxisX.value = rotAxis[0] * 100. ;
  sliderAxisY.value = rotAxis[1] * 100. ;
  sliderAxisZ.value = rotAxis[2] * 100. ;
  
  sliderTransX.value = transVec[0] * 100. ;
  sliderTransY.value = transVec[1] * 100. ;
  sliderTransZ.value = transVec[2] * 100. ;

  
  set_scaleMat();
  set_translationMat();
  set_rotationMat();
  
  set_textBoxes();
}


function draw_shape()
{
  if (shapeType==0)
    draw_sphere();
  if (shapeType==1)
    draw_polygon();
  if (shapeType==2)
    draw_prism();
  if (shapeType==3)
    draw_pyramid();
}


function set_textBoxes()
{
  document.getElementById("txt_rotAngle").innerHTML = rotAngleDeg;

  document.getElementById("txt_scaleX").innerHTML = scaleVec[0];
  document.getElementById("txt_scaleY").innerHTML = scaleVec[1];
  document.getElementById("txt_scaleZ").innerHTML = scaleVec[2];

  document.getElementById("txt_scaleMaxX").innerHTML = 200 / scale_sliderFac;
  document.getElementById("txt_scaleMaxY").innerHTML = 200 / scale_sliderFac;
  document.getElementById("txt_scaleMaxZ").innerHTML = 200 / scale_sliderFac;

  document.getElementById("txt_transX").innerHTML = transVec[0];
  document.getElementById("txt_transY").innerHTML = transVec[1];
  document.getElementById("txt_transZ").innerHTML = transVec[2];

  document.getElementById("txt_axX").innerHTML = rotAxis[0];
  document.getElementById("txt_axY").innerHTML = rotAxis[1];
  document.getElementById("txt_axZ").innerHTML = rotAxis[2];

}

function set_transformDefaults()
{
  rotAxis   = [0., 1., 0.];
  set_rotationMat();
}


function normalizeRotVec()
{
  rotAxisN = [0., 1., 0.];
  var norm = Math.sqrt(rotAxis[0]*rotAxis[0] +
                       rotAxis[1]*rotAxis[1] +
                       rotAxis[2]*rotAxis[2]  );
  if (norm > 0.01)
  {
    rotAxisN[0] = rotAxis[0] / norm;
    rotAxisN[1] = rotAxis[1] / norm;
    rotAxisN[2] = rotAxis[2] / norm;
  }
  else{
    rotAxis = [0., 1., 0.];
    sliderAxisX.value = rotAxis[0] * 100. ;
    sliderAxisY.value = rotAxis[1] * 100. ;
    sliderAxisZ.value = rotAxis[2] * 100. ;

  }
}


function set_rotationMat()
{
  var thRad = rotAngleDeg * Math.PI / 180.;
  normalizeRotVec();
  
  var cosTh = Math.cos(thRad);
  var sinTh = Math.sin(thRad);
  
  rotationMat = [
    [ rotAxisN[0]*rotAxisN[0] + (1.-rotAxisN[0]*rotAxisN[0]) * cosTh,
      rotAxisN[0]*rotAxisN[1] * (1.-cosTh) - rotAxisN[2] * sinTh,
      rotAxisN[0]*rotAxisN[2] * (1.-cosTh) + rotAxisN[1] * sinTh,
      0.],
    [ rotAxisN[0]*rotAxisN[1] * (1.-cosTh) + rotAxisN[2] * sinTh,
      rotAxisN[1]*rotAxisN[1] + (1.-rotAxisN[1]*rotAxisN[1])* cosTh,
      rotAxisN[1]*rotAxisN[2] * (1.-cosTh) - rotAxisN[0] * sinTh,
      0.],
    [ rotAxisN[0]*rotAxisN[2] * (1.-cosTh) - rotAxisN[1] * sinTh,
      rotAxisN[1]*rotAxisN[2] * (1.-cosTh) + rotAxisN[0] * sinTh,
      rotAxisN[2]*rotAxisN[2] + (1.-rotAxisN[2]*rotAxisN[2])* cosTh,
      0.],
    [0., 0., 0., 1.]];      
}

function set_translationMat()
{
  translationMat = [
    [1., 0., 0., transVec[0]],
    [0., 1., 0., transVec[1]],
    [0., 0., 1., transVec[2]],
    [0., 0., 0., 1.         ] ];      
}

function set_scaleMat()
{
  scaleMat = [
    [scaleVec[0], 0., 0., 0.],
    [0., scaleVec[1], 0., 0.],
    [0., 0., scaleVec[2], 0.],
    [0., 0., 0.         , 1.] ];      
}


function rotatePoint_zPlane(vertIn, angle_rad)
{
  var x = vertIn[0];
  var y = vertIn[1];
  
  vertIn[0] = x * Math.cos(angle_rad) - y * Math.sin(angle_rad);
  vertIn[1] = x * Math.sin(angle_rad) + y * Math.cos(angle_rad);
}



function gen_polygon(radIn, zVal, nVertices)
{
  var v0;
  var nVertices;
  var polyVerts = [];
  //var zVal = 0.
  
  
  if (typeof nVertices === 'undefined')
  {
    if (baseShape == 0)
      nVertices = 20;
    else
      nVertices = baseShape;
  }
  
  if (typeof zVal === 'undefined')
    zVal = 0.

  var rotationInRad  = 2. * Math.PI / nVertices;

  var vert0 = vec4(0., 0., zVal, 1.);
  polyVerts.push(vec4(vert0))

  var vert1 = vec4(0., radIn, zVal, 1.);
  if (baseShape==4)
    rotatePoint_zPlane(vert1, 0.25*Math.PI);


  for (v0=0; v0 < nVertices; v0++)
  {
    polyVerts.push(vec4(vert1))
    
    rotatePoint_zPlane(vert1, rotationInRad);
  }
  polyVerts.push(vec4(vert1));

  return polyVerts;
  
}


function matVectMult(matIn, vertIn)
{
  var vertOut = vec4(
    matIn[0][0] * vertIn[0] +
    matIn[0][1] * vertIn[1] +
    matIn[0][2] * vertIn[2] +
    matIn[0][3] * vertIn[3]   ,

    matIn[1][0] * vertIn[0] +
    matIn[1][1] * vertIn[1] +
    matIn[1][2] * vertIn[2] +
    matIn[1][3] * vertIn[3]   ,

    matIn[2][0] * vertIn[0] +
    matIn[2][1] * vertIn[1] +
    matIn[2][2] * vertIn[2] +
    matIn[2][3] * vertIn[3]   ,
    
    matIn[3][0] * vertIn[0] +
    matIn[3][1] * vertIn[1] +
    matIn[3][2] * vertIn[2] +
    matIn[3][3] * vertIn[3]     )
  
  return vertOut;
  
}


function transformVert(vertIn)
{
  var tmp = vec4(vertIn);
  
  tmp = matVectMult(scaleMat, tmp);
  tmp = matVectMult(rotationMat, tmp);
  tmp = matVectMult(translationMat, tmp);
  
  return tmp;
}


function transformShape()
{
  if (!bTransform)
    return;

  var v0, vi0;
  if (bTransform_fromOrig)
  {
    for (v0 = shapeVerts_start[shapeInd];
         v0 < shapeVerts_end[shapeInd];
         v0++)
    {
      vi0 = v0 - shapeVerts_start[shapeInd];
      vertices[v0] = transformVert(shape_archetype[vi0])
    } 
  }
  else
  {
    for (v0 = shapeVerts_start[shapeInd];
         v0 < shapeVerts_end[shapeInd];
         v0++)
      vertices[v0] = transformVert(vertices[v0])

  }
}


function draw_sphere()

{
  var v0, v1;
  var thetaInc = 2. * Math.PI / nCircVerts;
  var zSteps = nCircVerts / 4;

  var polyVerts = gen_polygon(radius);
  shape_archetype = [];
  
  var zVal, zValL, rho, rhoL;
  var theta, thetaP;
  
  // Top/bottom
  zVal = radius * Math.cos(thetaInc);
  rho  = radius * Math.sin(thetaInc);

  var topNode    = vec4(0., 0.,  radius, 1.);
  var bottomNode = vec4(0., 0., -radius, 1.);

  var node0 = vec4(rho * Math.cos(-thetaInc),
                  rho * Math.sin(-thetaInc),
                  zVal, 1.);
  var node1, node0b, node1b, node2, node2b, node3, node3b;
  
  for (v0=0; v0 < nCircVerts; v0++)
  {
    node0b = vec4(node0);
    node0b[2] = -zVal;
    node1 = vec4(rho * Math.cos(v0 * thetaInc),
                 rho * Math.sin(v0 * thetaInc),
                zVal, 1.);
    node1b = vec4(node1);
    node1b[2] = -zVal;

    // faces
    shape_archetype.push(vec4(topNode));
    shape_archetype.push(vec4(node0));
    shape_archetype.push(vec4(node1));
    // edges
    shape_archetype.push(vec4(topNode));
    shape_archetype.push(vec4(node0));
    shape_archetype.push(vec4(node1));
    if (bInitDraw)
    {
      nFaceVerts.push(3);
      vertices.push(vec4(topNode));
      vertices.push(vec4(node0));
      vertices.push(vec4(node1));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));

      nEdgeVerts.push(3);
      vertices.push(vec4(topNode));
      vertices.push(vec4(node0));
      vertices.push(vec4(node1));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      curvedEdges.push(nFaces);
      nFaces += 1;
    }

    // faces
    shape_archetype.push(vec4(bottomNode));
    shape_archetype.push(vec4(node0b));
    shape_archetype.push(vec4(node1b));
    // edges
    shape_archetype.push(vec4(bottomNode));
    shape_archetype.push(vec4(node0b));
    shape_archetype.push(vec4(node1b));
    if (bInitDraw)
    {
      nFaceVerts.push(3);
      vertices.push(vec4(bottomNode));
      vertices.push(vec4(node0b));
      vertices.push(vec4(node1b));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));

      nEdgeVerts.push(3);
      vertices.push(vec4(bottomNode));
      vertices.push(vec4(node0b));
      vertices.push(vec4(node1b));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      curvedEdges.push(nFaces);
      nFaces += 1;
    }
  
    node0 = vec4(node1);
  }
  
  for (v1=1; v1 < zSteps; v1++)
  {
    zVal  = radius * Math.cos( v1    * thetaInc);
    zValL = radius * Math.cos((v1+1) * thetaInc);
    rho   = radius * Math.sin( v1    * thetaInc);
    rhoL  = radius * Math.sin((v1+1) * thetaInc);
    

    for (v0=0; v0 < nCircVerts; v0++)
    {
      theta = thetaInc * v0;
      thetaP = theta + thetaInc;
      
      node0 = vec4(rho * Math.cos(theta ), rho * Math.sin(theta ),
                   zVal , 1.);
      node1 = vec4(rho * Math.cos(thetaP), rho * Math.sin(thetaP),
                   zVal , 1.);
      node2 = vec4(rhoL* Math.cos(thetaP), rhoL* Math.sin(thetaP),
                   zValL, 1.);
      node3 = vec4(rhoL* Math.cos(theta ), rhoL* Math.sin(theta ),
                   zValL, 1.);
    
      // faces
      shape_archetype.push(vec4(node0));
      shape_archetype.push(vec4(node1));
      shape_archetype.push(vec4(node2));
      shape_archetype.push(vec4(node3));
      // edges
      shape_archetype.push(vec4(node0));
      shape_archetype.push(vec4(node1));
      shape_archetype.push(vec4(node2));
      shape_archetype.push(vec4(node3));
      if (bInitDraw)
      {
        nFaceVerts.push(4);
        vertices.push(vec4(node0));
        vertices.push(vec4(node1));
        vertices.push(vec4(node2));
        vertices.push(vec4(node3));
        vertexColors.push(vec4(faceColor));
        vertexColors.push(vec4(faceColor));
        vertexColors.push(vec4(faceColor));
        vertexColors.push(vec4(faceColor));

        nEdgeVerts.push(4);
        vertices.push(vec4(node0));
        vertices.push(vec4(node1));
        vertices.push(vec4(node2));
        vertices.push(vec4(node3));
        vertexColors.push(vec4(edgeColor));
        vertexColors.push(vec4(edgeColor));
        vertexColors.push(vec4(edgeColor));
        vertexColors.push(vec4(edgeColor));
        curvedEdges.push(nFaces);
        nFaces += 1;
      }
      
      node0[2] = -node0[2];
      node1[2] = -node1[2];
      node2[2] = -node2[2];
      node3[2] = -node3[2];
      
      // faces
      shape_archetype.push(vec4(node0));
      shape_archetype.push(vec4(node1));
      shape_archetype.push(vec4(node2));
      shape_archetype.push(vec4(node3));
      // edges
      shape_archetype.push(vec4(node0));
      shape_archetype.push(vec4(node1));
      shape_archetype.push(vec4(node2));
      shape_archetype.push(vec4(node3));
      if (bInitDraw)
      {
        nFaceVerts.push(4);
        vertices.push(vec4(node0));
        vertices.push(vec4(node1));
        vertices.push(vec4(node2));
        vertices.push(vec4(node3));
        vertexColors.push(vec4(faceColor));
        vertexColors.push(vec4(faceColor));
        vertexColors.push(vec4(faceColor));
        vertexColors.push(vec4(faceColor));

        nEdgeVerts.push(4);
        vertices.push(vec4(node0));
        vertices.push(vec4(node1));
        vertices.push(vec4(node2));
        vertices.push(vec4(node3));
        vertexColors.push(vec4(edgeColor));
        vertexColors.push(vec4(edgeColor));
        vertexColors.push(vec4(edgeColor));
        vertexColors.push(vec4(edgeColor));
        curvedEdges.push(nFaces);
        nFaces += 1;
      }
    }
  }

  
}  





function draw_polygon()

{
  var v0;

  var polyVerts = gen_polygon(radius);
  shape_archetype = [];
  
  var nVertices = polyVerts.length - 2;
  if (bInitDraw)
  {
    nFaceVerts.push(nVertices + 2);
    nEdgeVerts.push(nVertices);
  }
    
  // Add base
  shape_archetype.push(vec4(polyVerts[0]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[0]));
    vertexColors.push(vec4(faceColor));
  }
  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(faceColor));
    }
  }
  shape_archetype.push(vec4(polyVerts[1]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[1]));
    vertexColors.push(vec4(faceColor));
  }

  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(edgeColor));
    }    
  }

  if (bInitDraw)
    nFaces += 1;
  
}


function draw_prism()
{
  var v0;
  shape_archetype = [];
  var tmp1, tmp2;

  // Add base
  var polyVerts = gen_polygon(radius);
  var nVertices = polyVerts.length - 2;
  if (bInitDraw)
  {
    nFaceVerts.push(nVertices + 2);
    nEdgeVerts.push(nVertices);
  }
    
  shape_archetype.push(vec4(polyVerts[0]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[0]));
    vertexColors.push(vec4(faceColor));
  }
  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(faceColor));
    }
  }
  shape_archetype.push(vec4(polyVerts[1]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[1]));
    vertexColors.push(vec4(faceColor));
  }

  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(edgeColor));
    }    
  }

  if (bInitDraw)
    nFaces += 1;

  
  // Add top
  polyVerts = gen_polygon(radius, height);
  
  var nVertices = polyVerts.length - 2;
  if (bInitDraw)
  {
    nFaceVerts.push(nVertices + 2);
    nEdgeVerts.push(nVertices);
  }

  shape_archetype.push(vec4(polyVerts[0]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[0]));
    vertexColors.push(vec4(faceColor));
  }
  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(faceColor));
    }
  }
  shape_archetype.push(vec4(polyVerts[1]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[1]));
    vertexColors.push(vec4(faceColor));
  }

  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(edgeColor));
    }    
  }

  if (bInitDraw)
    nFaces += 1;
  
  // Add sides
  for (v0=0; v0 < nVertices; v0++)
  {

    // Faces
    tmp1 = vec4(polyVerts[v0+1]);
    tmp2 = vec4(polyVerts[v0+2]);
    tmp1[2] = 0;
    tmp2[2] = 0;
    shape_archetype.push(vec4(polyVerts[v0+1]));
    shape_archetype.push(vec4(polyVerts[v0+2]));
    shape_archetype.push(vec4(tmp2));
    shape_archetype.push(vec4(tmp1));

    if (bInitDraw)
    {
      nFaceVerts.push(4);
      vertices.push(vec4(polyVerts[v0+1]));
      vertices.push(vec4(polyVerts[v0+2]));
      vertices.push(vec4(tmp2));
      vertices.push(vec4(tmp1));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));
    }
      
    // Edges
    shape_archetype.push(vec4(polyVerts[v0+1]));
    shape_archetype.push(vec4(polyVerts[v0+2]));
    shape_archetype.push(vec4(tmp2));
    shape_archetype.push(vec4(tmp1));
    if (bInitDraw)
    {
      nEdgeVerts.push(4);
      vertices.push(vec4(polyVerts[v0+1]));
      vertices.push(vec4(polyVerts[v0+2]));
      vertices.push(vec4(tmp2));
      vertices.push(vec4(tmp1));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      if (baseShape == CIRC_BASE_IND)
        curvedEdges.push(nFaces);
      nFaces += 1;
    }

  }
}


function draw_pyramid()
{
  var v0;

  var polyVerts = gen_polygon(radius);
  shape_archetype = [];
  
  var nVertices = polyVerts.length - 2;
  if (bInitDraw)
  {
    nFaceVerts.push(nVertices + 2);
    nEdgeVerts.push(nVertices);
  }
    
  // Add base
  shape_archetype.push(vec4(polyVerts[0]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[0]));
    vertexColors.push(vec4(faceColor));
  }
  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(faceColor));
    }
  }
  shape_archetype.push(vec4(polyVerts[1]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[1]));
    vertexColors.push(vec4(faceColor));
  }

  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(edgeColor));
    }    
  }

  if (bInitDraw)
    nFaces += 1;
  
  // Add sides
  var apex = vec4(polyVerts[0]);
  apex[2] = -height
  for (v0=0; v0 < nVertices; v0++)
  {

    // Faces
    shape_archetype.push(vec4(polyVerts[v0+1]));
    shape_archetype.push(vec4(polyVerts[v0+2]));
    shape_archetype.push(vec4(apex));
      
    if (bInitDraw)
    {
      nFaceVerts.push(3);
      vertices.push(vec4(polyVerts[v0+1]));
      vertices.push(vec4(polyVerts[v0+2]));
      vertices.push(vec4(apex));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));
    }
      
    // Edges
    shape_archetype.push(vec4(polyVerts[v0+1]));
    shape_archetype.push(vec4(polyVerts[v0+2]));
    shape_archetype.push(vec4(apex));
    if (bInitDraw)
    {
      nEdgeVerts.push(3);
      vertices.push(vec4(polyVerts[v0+1]));
      vertices.push(vec4(polyVerts[v0+2]));
      vertices.push(vec4(apex));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      if (baseShape == CIRC_BASE_IND)
        curvedEdges.push(nFaces);
      nFaces += 1;
    }

  }
  
  
  // Add point to cone for when "curved"-edge surfaces are hidden.
  //   use small triangle to create "point"
  if (baseShape == CIRC_BASE_IND)
  {
    var capVerts = gen_polygon(radius * 0.01, 0., 3);
    
    // Swap x- and z-values, then translate to height
        
    // Swap x- and z-values, then translate to height
    for (v0=0; v0 < capVerts.length; v0++)
    {
      var tmp = capVerts[v0][1];
      capVerts[v0][1] = capVerts[v0][2];
      capVerts[v0][2] = tmp - height;
    }

    nVertices = capVerts.length - 2;
    if (bInitDraw)
    {
      nFaceVerts.push(nVertices + 2);
      nEdgeVerts.push(nVertices);
    }
    
    shape_archetype.push(vec4(capVerts[0]));
    if (bInitDraw)
    {
      vertices.push(vec4(capVerts[0]));
      vertexColors.push(vec4(faceColor));
    }
    for (v0=0; v0 < nVertices; v0++)
    {
      shape_archetype.push(vec4(capVerts[v0+1]));
      if (bInitDraw)
      {
        vertices.push(vec4(capVerts[v0+1]));
        vertexColors.push(vec4(faceColor));
      }
    }
    shape_archetype.push(vec4(capVerts[1]));
    if (bInitDraw)
    {
      vertices.push(vec4(capVerts[1]));
      vertexColors.push(vec4(faceColor));
    }

    for (v0=0; v0 < nVertices; v0++)
    {
      shape_archetype.push(vec4(capVerts[v0+1]));
      if (bInitDraw)
      {
        vertices.push(vec4(capVerts[v0+1]));
        vertexColors.push(vec4(edgeColor));
      }    
    }

    if (bInitDraw)
      nFaces += 1;
  }
  
}


function render()
{
  gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  bDraw_check();
  if (!bDraw)
    return;
  
  transformShape();
  
  bWireframe = check_wireframe.checked;
  bShowCurvedEdges = check_showCurvedEdges.checked;
  
  
  var v0=0;
  var f0;
  var i0;
  var bDrawEdge;

  gl.bindBuffer( gl.ARRAY_BUFFER, vBuffer );
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, flatten(vertices));

  gl.bindBuffer( gl.ARRAY_BUFFER, cBuffer );
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, flatten(vertexColors));

  v0 = 0;
  for (f0=0; f0 < nFaces; f0++)
  {
    if (!bWireframe)
      gl.drawArrays(gl.TRIANGLE_FAN, v0, nFaceVerts[f0]);
    v0 += nFaceVerts[f0];
    
    bDrawEdge = true;
    if (!bShowCurvedEdges && curvedEdges.indexOf(f0) > -1)
      bDrawEdge = false;
    if (bDrawEdge)
        gl.drawArrays(gl.LINE_LOOP, v0, nEdgeVerts[f0]);
    v0 += nEdgeVerts[f0];
   
  }
  
  
}

//2345678901234567890123456789012345678901234567890123456789012345678901234567890
//        1         2         3         4         5         6         7         8