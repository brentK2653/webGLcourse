"use strict";

var canvas ;
var gl ;

/* Things left to do:
 * + fix pyramids
 * + translations
 * + curved sides
 * - scaling
 * - prism
 * - sphere
 * - check boxes
 */

var maxNumVertices = 2000;

var radius_default      = 1.0;
var height_default      = 1.0;
var rotAngleDeg_default =  0;

var scaleVec_default    = [0.2, 0.2, 0.2];
var rotAxis_default     = [0., 1., 0.];
var transVec_default    = [0., 0., 0.];




var vertices     = [];
var vertexColors = [];

// Edges generated by gl.LINE_LOOP
var nEdgeVerts   = [];

var edgeColor;

// Faces generated by gl.TRIANGLE_FAN
var nFaces       =  0;
var nFaceVerts   = [];

var faceColor;

var totalPoints  =  0 ;

var faceColorI = 3;
var edgeColorI = 0;

var shapeType = 3;
var baseShape = 4;

var curvedEdges = [];

var radius      = radius_default;
var height      = height_default;
var rotAngleDeg = rotAngleDeg_default;

var scaleVec    = vec3(scaleVec_default);
var rotAxis     = vec3(rotAxis_default);
var transVec    = vec3(transVec_default);

var nCircVerts  = 20;

var bDraw            = false;
var bTransform       = false;
var bInitDraw        = false;
var bShowCurvedEdges = true;
var bWireframe       = false;
var CIRC_BASE_IND         = 0;

var rotAxisN;
var shape_archetype;
var scaleMat;
var rotationMat;
var translationMat;

var vBuffer;
var cBuffer;


var shapeVerts_start = [];
var shapeVerts_end   = [];
var shapeInd         = -1;

var colors = [
    vec4( 0.0, 0.0, 0.0, 1.0 ),  // black
    vec4( 1.0, 1.0, 1.0, 1.0 ),  // white
    vec4( 1.0, 0.0, 0.0, 1.0 ),  // red
    vec4( 0.0, 1.0, 0.0, 1.0 ),  // green
    vec4( 0.0, 0.0, 1.0, 1.0 )   // blue
  ];

// Define outside of onload() so we can set these elsewhere.
var sliderRot;

var sliderScaleX;
var sliderScaleY;
var sliderScaleZ;

var sliderTransX;
var sliderTransY;
var sliderTransZ;

var sliderAxisX;
var sliderAxisY;
var sliderAxisZ;

var check_showCurvedEdges;
var check_wireframe;


  
  
function bDraw_check()
{
  bDraw = true;
  if (parseInt(faceColorI) === -1)
    bDraw = false;
  if (parseInt(edgeColorI) === -1)
    bDraw = false;
  if (parseInt(shapeType)  === -1)
    bDraw = false;
  if (parseInt(baseShape)  === -1)
    bDraw = false;
}



window.onload = function init()
{
  canvas = document.getElementById( "gl-canvas" );

  gl = WebGLUtils.setupWebGL( canvas );
  if ( !gl ) { alert( "WebGL isn't available" ); }

  //  Configure WebGL
  gl.viewport( 0, 0, canvas.width, canvas.height );
  gl.clearColor( 1.0, 1.0, 1.0, 1.0 );
  gl.enable(gl.DEPTH_TEST);;


  //  Load shaders and initialize attribute buffers
  var program = initShaders( gl, "vertex-shader", "fragment-shader" );
  gl.useProgram( program );
  
  

  // color array atrribute buffer

  vBuffer = gl.createBuffer();
  gl.bindBuffer( gl.ARRAY_BUFFER, vBuffer );
  gl.bufferData( gl.ARRAY_BUFFER, 8*maxNumVertices, gl.STATIC_DRAW );

  var vPosition = gl.getAttribLocation(program, "vPosition");
  gl.vertexAttribPointer(vPosition, 4, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(vPosition);

  cBuffer = gl.createBuffer();
  gl.bindBuffer( gl.ARRAY_BUFFER, cBuffer );
  gl.bufferData( gl.ARRAY_BUFFER, 16*maxNumVertices, gl.STATIC_DRAW );

  var vColor = gl.getAttribLocation( program, "vColor" );
  gl.vertexAttribPointer( vColor, 4, gl.FLOAT, false, 0, 0 );
  gl.enableVertexAttribArray( vColor );

  // Event listeners
  

  faceColor  = colors[faceColorI];
  var faceColorIPicker = document.getElementById("faceColorI");
  faceColorIPicker.selectedIndex = faceColorI;
  faceColorIPicker.addEventListener("click",
    function()
    {
      faceColorI = faceColorIPicker.selectedIndex;
      faceColor  = colors[faceColorI];
    }
  )  

  edgeColor  = colors[edgeColorI];
  var edgeColorIPicker = document.getElementById("edgeColorI");
  edgeColorIPicker.selectedIndex = edgeColorI;
  edgeColorIPicker.addEventListener("click",
    function()
    {
      edgeColorI = edgeColorIPicker.selectedIndex;
      edgeColor  = colors[edgeColorI];
    }
  )  

  var shapeTypePicker = document.getElementById("shapeType");
  shapeTypePicker.value = shapeType; 
  shapeTypePicker.addEventListener("click",
    function()
    {
      shapeType = parseInt(shapeTypePicker.value);
    }
  )  

  var baseShapePicker = document.getElementById("baseShape");
  baseShapePicker.value = baseShape;
  baseShapePicker.addEventListener("click",
    function()
    {
      baseShape = parseInt(baseShapePicker.value);
    }
  )  

  sliderRot = document.getElementById("sliderRot");
  sliderRot.value = rotAngleDeg;
  sliderRot.addEventListener("mouseup",
    function()
    {
      rotAngleDeg = parseInt(sliderRot.value);
      set_textBoxes();
      draw_shape();
      set_rotationMat();
      render();
    }
  )

 
  sliderScaleX = document.getElementById("sliderScaleX");
  sliderScaleY = document.getElementById("sliderScaleY");
  sliderScaleZ = document.getElementById("sliderScaleZ");

  sliderScaleX.value = scaleVec[0] * 50. ;
  sliderScaleX.addEventListener("mouseup",
    function()
    {
      scaleVec[0] = sliderScaleX.value / 50. ;
      set_textBoxes();
      set_scaleMat();
      render();
    }
  )

  sliderScaleY.value = scaleVec[1] * 50. ;
  sliderScaleY.addEventListener("mouseup",
    function()
    {
      scaleVec[1] = sliderScaleY.value / 50. ;
      set_textBoxes();
      set_scaleMat();
      render();
    }
  )

  sliderScaleZ.value = scaleVec[2] * 50. ;
  sliderScaleZ.addEventListener("mouseup",
    function()
    {
      scaleVec[2] = sliderScaleZ.value / 50. ;
      set_textBoxes();
      set_scaleMat();
      render();
    }
  )

 
  sliderAxisX = document.getElementById("sliderAxisX");
  sliderAxisY = document.getElementById("sliderAxisY");
  sliderAxisZ = document.getElementById("sliderAxisZ");

  sliderAxisX.value = rotAxis[0] * 100. ;
  sliderAxisX.addEventListener("mouseup",
    function()
    {
      rotAxis[0] = sliderAxisX.value / 100. ;
      set_textBoxes();
      set_rotationMat();
      render();
    }
  )

  sliderAxisY.value = rotAxis[1] * 100. ;
  sliderAxisY.addEventListener("mouseup",
    function()
    {
      rotAxis[1] = sliderAxisY.value / 100. ;
      set_textBoxes();
      set_rotationMat();
      render();
    }
  )

  sliderAxisZ.value = rotAxis[2] * 100. ;
  sliderAxisZ.addEventListener("mouseup",
    function()
    {
      rotAxis[2] = sliderAxisZ.value / 100. ;
      set_rotationMat();
      set_textBoxes();
      render();
    }
  )

  sliderTransX = document.getElementById("sliderTransX");
  sliderTransY = document.getElementById("sliderTransY");
  sliderTransZ = document.getElementById("sliderTransZ");

  sliderTransX.value = transVec[0] * 100. ;
  sliderTransX.addEventListener("mouseup",
    function()
    {
      transVec[0] = sliderTransX.value / 100. ;
      set_textBoxes();
      set_translationMat();
      render();
    }
  )

  sliderTransY.value = transVec[1] * 100. ;
  sliderTransY.addEventListener("mouseup",
    function()
    {
      transVec[1] = sliderTransY.value / 100. ;
      set_textBoxes();
      set_translationMat();
      render();
    }
  )

  sliderTransZ.value = transVec[2] * 100. ;
  sliderTransZ.addEventListener("mouseup",
    function()
    {
      transVec[2] = sliderTransZ.value / 100. ;
      set_textBoxes();
      set_translationMat();
      render();
    }
  )

  check_wireframe = document.getElementById("check_wireframe");
  check_wireframe.checked = bWireframe;
  check_wireframe.addEventListener("mousedown",
    function()
    {
      bWireframe = check_wireframe.checked;
      console.log(bWireframe);
      set_rotationMat();
      transformShape();
      render();
    }
  )
  
  reset_vals();
  
  var drawButton = document.getElementById("drawButton");
  drawButton.addEventListener("click",
    function()
    {
      console.log("click");
      bDraw_check();
      if (bDraw)
      {
        shapeInd += 1;
        bInitDraw = true;
        shapeVerts_start.push(vertices.length);
        reset_vals();
        console.log(transVec)
        draw_shape();
        bInitDraw = false;
        shapeVerts_end.push(vertices.length);
        bTransform = true;
        render();
      }
    }
  )

  set_textBoxes();
  
  
}


function reset_vals()
{
  radius = radius_default;
  height = height_default;
  rotAngleDeg = rotAngleDeg_default;

  scaleVec = vec3(scaleVec_default);
  rotAxis  = vec3(rotAxis_default);
  transVec = vec3(transVec_default);

  sliderRot.value = rotAngleDeg;
  
  sliderScaleX.value = scaleVec[0] * 50. ;
  sliderScaleY.value = scaleVec[1] * 50. ;
  sliderScaleZ.value = scaleVec[2] * 50. ;
  
  sliderAxisX.value = rotAxis[0] * 100. ;
  sliderAxisY.value = rotAxis[1] * 100. ;
  sliderAxisZ.value = rotAxis[2] * 100. ;
  
  sliderTransX.value = transVec[0] * 100. ;
  sliderTransY.value = transVec[1] * 100. ;
  sliderTransZ.value = transVec[2] * 100. ;

  
  set_scaleMat();
  set_translationMat();
  set_rotationMat();
  
  set_textBoxes();
}


function draw_shape()
{
  if (shapeType==1)
    draw_polygon();
  if (shapeType==3)
    draw_pyramid();
}


function set_textBoxes()
{
  document.getElementById("txt_rotAngle").innerHTML = rotAngleDeg;

  document.getElementById("txt_scaleX").innerHTML = scaleVec[0];
  document.getElementById("txt_scaleY").innerHTML = scaleVec[1];
  document.getElementById("txt_scaleZ").innerHTML = scaleVec[2];

  document.getElementById("txt_transX").innerHTML = transVec[0];
  document.getElementById("txt_transY").innerHTML = transVec[1];
  document.getElementById("txt_transZ").innerHTML = transVec[2];

  document.getElementById("txt_axX").innerHTML = rotAxis[0];
  document.getElementById("txt_axY").innerHTML = rotAxis[1];
  document.getElementById("txt_axZ").innerHTML = rotAxis[2];

}

function set_transformDefaults()
{
  rotAxis   = [0., 1., 0.];
  set_rotationMat();
}


function normalizeRotVec()
{
  rotAxisN = [0., 1., 0.];
  var norm = Math.sqrt(rotAxis[0]*rotAxis[0] +
                       rotAxis[1]*rotAxis[1] +
                       rotAxis[2]*rotAxis[2]  );
  if (norm > 0.01)
  {
    rotAxisN[0] = rotAxis[0] / norm;
    rotAxisN[1] = rotAxis[1] / norm;
    rotAxisN[2] = rotAxis[2] / norm;
  }
  else{
    rotAxis = [0., 1., 0.];
    sliderAxisX.value = rotAxis[0] * 100. ;
    sliderAxisY.value = rotAxis[1] * 100. ;
    sliderAxisZ.value = rotAxis[2] * 100. ;

  }
}


function set_rotationMat()
{
  var thRad = rotAngleDeg * Math.PI / 180.;
  normalizeRotVec();
  
  var cosTh = Math.cos(thRad);
  var sinTh = Math.sin(thRad);
  
  rotationMat = [
    [ rotAxisN[0]*rotAxisN[0] + (1.-rotAxisN[0]*rotAxisN[0]) * cosTh,
      rotAxisN[0]*rotAxisN[1] * (1.-cosTh) - rotAxisN[2] * sinTh,
      rotAxisN[0]*rotAxisN[2] * (1.-cosTh) + rotAxisN[1] * sinTh,
      0.],
    [ rotAxisN[0]*rotAxisN[1] * (1.-cosTh) + rotAxisN[2] * sinTh,
      rotAxisN[1]*rotAxisN[1] + (1.-rotAxisN[1]*rotAxisN[1])* cosTh,
      rotAxisN[1]*rotAxisN[2] * (1.-cosTh) - rotAxisN[0] * sinTh,
      0.],
    [ rotAxisN[0]*rotAxisN[2] * (1.-cosTh) - rotAxisN[1] * sinTh,
      rotAxisN[1]*rotAxisN[2] * (1.-cosTh) + rotAxisN[0] * sinTh,
      rotAxisN[2]*rotAxisN[2] + (1.-rotAxisN[2]*rotAxisN[2])* cosTh,
      0.],
    [0., 0., 0., 1.]];      
}

function set_translationMat()
{
  translationMat = [
    [1., 0., 0., transVec[0]],
    [0., 1., 0., transVec[1]],
    [0., 0., 1., transVec[2]],
    [0., 0., 0., 1.         ] ];      
}

function set_scaleMat()
{
  scaleMat = [
    [scaleVec[0], 0., 0., 0.],
    [0., scaleVec[1], 0., 0.],
    [0., 0., scaleVec[2], 0.],
    [0., 0., 0.         , 1.] ];      
}


function rotatePoint_zPlane(vertIn, angle_rad)
{
  var x = vertIn[0];
  var y = vertIn[1];
  
  vertIn[0] = x * Math.cos(angle_rad) - y * Math.sin(angle_rad);
  vertIn[1] = x * Math.sin(angle_rad) + y * Math.cos(angle_rad);
}



function gen_polygon(radIn, nVertices, zVal)
{
  var v0;
  var nVertices;
  var polyVerts = [];
  //var zVal = 0.
  
  
  if (typeof nVertices === 'undefined')
  {
    if (baseShape == 0)
      nVertices = 20;
    else
      nVertices = baseShape;
  }
  
  if (typeof zVal === 'undefined')
    zVal = 0.

  var rotationInRad  = 2. * Math.PI / nVertices;

  var vert0 = vec4(0., 0., zVal, 1.);
  polyVerts.push(vec4(vert0))

  var vert1 = vec4(0., radIn, zVal, 1.);


  for (v0=0; v0 < nVertices; v0++)
  {
    polyVerts.push(vec4(vert1))
    
    rotatePoint_zPlane(vert1, rotationInRad);
  }
  polyVerts.push(vec4(vert1));

  return polyVerts;
  
}


function matVectMult(matIn, vertIn)
{
  var vertOut = vec4(
    matIn[0][0] * vertIn[0] +
    matIn[0][1] * vertIn[1] +
    matIn[0][2] * vertIn[2] +
    matIn[0][3] * vertIn[3]   ,

    matIn[1][0] * vertIn[0] +
    matIn[1][1] * vertIn[1] +
    matIn[1][2] * vertIn[2] +
    matIn[1][3] * vertIn[3]   ,

    matIn[2][0] * vertIn[0] +
    matIn[2][1] * vertIn[1] +
    matIn[2][2] * vertIn[2] +
    matIn[2][3] * vertIn[3]   ,
    
    matIn[3][0] * vertIn[0] +
    matIn[3][1] * vertIn[1] +
    matIn[3][2] * vertIn[2] +
    matIn[3][3] * vertIn[3]     )
  
  return vertOut;
  
}


function transformVert(vertIn)
{
  var tmp = vec4(vertIn);
  
  tmp = matVectMult(scaleMat, tmp);
  tmp = matVectMult(rotationMat, tmp);
  tmp = matVectMult(translationMat, tmp);
  
  return tmp;
}


function transformShape()
{
  if (!bTransform)
    return;

  var v0, vi0;
  for (v0 = shapeVerts_start[shapeInd];
       v0 < shapeVerts_end[shapeInd];
       v0++)
  {
    vi0 = v0 - shapeVerts_start[shapeInd];
    vertices[v0] = transformVert(shape_archetype[vi0])
  }
}


function draw_polygon()
{
  var v0;

  var polyVerts = gen_polygon(radius);
  shape_archetytpe = [];
 
  var nVertices = polyVerts.length - 2;

  // Add faces
  shape_archetype.push(vec4(polyVerts[0]));
  if (bInitDraw)
  {
    nFaceVerts.push(nVertices + 2);
    nEdgeVerts.push(nVertices);
    vertices.push(vec4(polyVerts[0]));
    vertexColors.push(vec4(faceColor));
  }
  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(faceColor));
    }
      
  }
  shape_archetype.push(vec4(polyVerts[1]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[1]));
    vertexColors.push(vec4(faceColor));
  }

  // Add edges
  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(edgeColor));
    }
  }

  if (bInitDraw)
    nFaces += 1;

}


function draw_pyramid()
{
  var v0;

  var polyVerts = gen_polygon(radius);
  shape_archetype = [];
  
  var nVertices = polyVerts.length - 2;
  if (bInitDraw)
  {
    nFaceVerts.push(nVertices + 2);
    nEdgeVerts.push(nVertices);
  }
    
  // Add base
  shape_archetype.push(vec4(polyVerts[0]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[0]));
    vertexColors.push(vec4(faceColor));
  }
  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(faceColor));
    }
  }
  shape_archetype.push(vec4(polyVerts[1]));
  if (bInitDraw)
  {
    vertices.push(vec4(polyVerts[1]));
    vertexColors.push(vec4(faceColor));
  }

  for (v0=0; v0 < nVertices; v0++)
  {
    shape_archetype.push(vec4(polyVerts[v0+1]));
    if (bInitDraw)
    {
      vertices.push(vec4(polyVerts[v0+1]));
      vertexColors.push(vec4(edgeColor));
    }    
  }

  if (bInitDraw)
    nFaces += 1;
  
  // Add sides
  var apex = vec4(polyVerts[0]);
  apex[2] = -height
  for (v0=0; v0 < nVertices; v0++)
  {

    // Faces
    shape_archetype.push(vec4(polyVerts[v0+1]));
    shape_archetype.push(vec4(polyVerts[v0+2]));
    shape_archetype.push(vec4(apex));
      
    if (bInitDraw)
    {
      nFaceVerts.push(3);
      vertices.push(vec4(polyVerts[v0+1]));
      vertices.push(vec4(polyVerts[v0+2]));
      vertices.push(vec4(apex));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));
      vertexColors.push(vec4(faceColor));
    }
      
    // Edges
    shape_archetype.push(vec4(polyVerts[v0+1]));
    shape_archetype.push(vec4(polyVerts[v0+2]));
    shape_archetype.push(vec4(apex));
    if (bInitDraw)
    {
      nEdgeVerts.push(3);
      vertices.push(vec4(polyVerts[v0+1]));
      vertices.push(vec4(polyVerts[v0+2]));
      vertices.push(vec4(apex));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      vertexColors.push(vec4(edgeColor));
      if (baseShape == CIRC_BASE_IND)
        curvedEdges.push(nFaces);
      nFaces += 1;
    }

  }
  
  
  // Add point to cone for when "curved"-edge surfaces are hidden.
  //   use small triangle to create "point"
  if (baseShape == CIRC_BASE_IND)
  {
    var capVerts = gen_polygon(radius * 0.01, 3, 0.);
    
    // Swap x- and z-values, then translate to height
        
    // Swap x- and z-values, then translate to height
    for (v0=0; v0 < capVerts.length; v0++)
    {
      var tmp = capVerts[v0][1];
      capVerts[v0][1] = capVerts[v0][2];
      capVerts[v0][2] = tmp - height;
    }

    nVertices = capVerts.length - 2;
    if (bInitDraw)
    {
      nFaceVerts.push(nVertices + 2);
      nEdgeVerts.push(nVertices);
    }
    
    shape_archetype.push(vec4(capVerts[0]));
    if (bInitDraw)
    {
      vertices.push(vec4(capVerts[0]));
      vertexColors.push(vec4(faceColor));
    }
    for (v0=0; v0 < nVertices; v0++)
    {
      shape_archetype.push(vec4(capVerts[v0+1]));
      if (bInitDraw)
      {
        vertices.push(vec4(capVerts[v0+1]));
        vertexColors.push(vec4(faceColor));
      }
    }
    shape_archetype.push(vec4(capVerts[1]));
    if (bInitDraw)
    {
      vertices.push(vec4(capVerts[1]));
      vertexColors.push(vec4(faceColor));
    }

    for (v0=0; v0 < nVertices; v0++)
    {
      shape_archetype.push(vec4(capVerts[v0+1]));
      if (bInitDraw)
      {
        vertices.push(vec4(capVerts[v0+1]));
        vertexColors.push(vec4(edgeColor));
      }    
    }

    if (bInitDraw)
      nFaces += 1;
  }
  
}


function render()
{
  gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  bDraw_check();
  if (!bDraw)
    return;
  
  transformShape();
  
  console.log("render");
  
  var v0=0;
  var f0;
  var i0;
  var bDrawEdge;

  gl.bindBuffer( gl.ARRAY_BUFFER, vBuffer );
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, flatten(vertices));

  gl.bindBuffer( gl.ARRAY_BUFFER, cBuffer );
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, flatten(vertexColors));

  v0 = 0;
  for (f0=0; f0 < nFaces; f0++)
  {
    //console.log("f0, nFaceVerts, nEdgeVerts = %d, %d, %d",
    //             f0, nFaceVerts[f0], nEdgeVerts[f0]); 
    if (!bWireframe)
      gl.drawArrays(gl.TRIANGLE_FAN, v0, nFaceVerts[f0]);
    v0 += nFaceVerts[f0];
    
    bDrawEdge = true;
    if (!bShowCurvedEdges && curvedEdges.indexOf(f0) > -1)
      bDrawEdge = false;
    if (bDrawEdge)
      gl.drawArrays(gl.LINE_LOOP, v0, nEdgeVerts[f0]);
    v0 += nEdgeVerts[f0];
   
  }
  //console.log(v0);
  
  
  
}

//2345678901234567890123456789012345678901234567890123456789012345678901234567890
//        1         2         3         4         5         6         7         8